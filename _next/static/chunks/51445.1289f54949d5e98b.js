"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[51445],{73853:function(t,a,e){e.d(a,{D:function(){return g},F:function(){return l},I:function(){return c},a:function(){return p},b:function(){return u},c:function(){return h},f:function(){return d},g:function(){return y},u:function(){return f}});var r=e(15418),n=e(46347),o=e(61501),s=e(8400),i=e(23663).Buffer;let c=n.arrayify("0x80ac58cd"),p=n.arrayify("0xd9b67a26"),l={name:"Failed to load NFT metadata"};async function d(t,a,e){let s;if(a.startsWith("data:application/json;base64")&&void 0!==i){let e=a.split(",")[1],n=JSON.parse(i.from(e,"base64").toString("utf-8"));return r.a.parse({...n,id:o.O$.from(t).toString(),uri:a})}let c=a.replace("{id}",n.hexZeroPad(o.O$.from(t).toHexString(),32).slice(2));try{s=await e.downloadJSON(c)}catch(n){let r=a.replace("{id}",o.O$.from(t).toString());try{s=await e.downloadJSON(r)}catch(e){console.warn("failed to get token metadata: ".concat(JSON.stringify({tokenId:t.toString(),tokenUri:a})," -- falling back to default metadata")),s=l}}return r.a.parse({...s,id:o.O$.from(t).toString(),uri:a})}async function h(t,a,n,i){let h;let u=(await e.e(31787).then(e.t.bind(e,31787,19))).default,f=new s.CH(t,u,a),[y,g]=await Promise.all([f.supportsInterface(c),f.supportsInterface(p)]);if(y){let r=(await Promise.resolve().then(e.t.bind(e,19115,19))).default,o=new s.CH(t,r,a);h=await o.tokenURI(n)}else if(g){let r=(await Promise.resolve().then(e.t.bind(e,31617,19))).default,o=new s.CH(t,r,a);h=await o.uri(n)}else throw Error("Contract must implement ERC 1155 or ERC 721.");return h?d(n,h,i):r.a.parse({...l,id:o.O$.from(n).toString(),uri:""})}async function u(t,a){return"string"==typeof t?t:await a.upload(r.C.parse(t))}async function f(t,a,e,n){if(void 0===t.find(t=>"string"!=typeof t))return t;if(void 0===t.find(t=>"object"!=typeof t))return await a.uploadBatch(t.map(t=>r.C.parse(t)),{rewriteFileNames:{fileStartNumber:e||0},onProgress:null==n?void 0:n.onProgress});throw Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function y(t){let a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){let r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw Error("Can only create batches with the same base URI for every entry in the batch. Expected '".concat(a,"' but got '").concat(r,"'"))}return a.replace(/\/$/,"")+"/"}let g=100},51445:function(t,a,e){e.d(a,{C:function(){return w},D:function(){return m},a:function(){return W},c:function(){return I}});var r=e(13545),n=e(21325),o=e(89586),s=e(12158),i=e(46347),c=e(35368),p=e(61501),l=e(57289),d=e(8400),h=e(60105),u=e(15418),f=e(73853),y=e(23198),g=e(78680);class w{async getDefaultRoyaltyInfo(){let[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return o.bF.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){let[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return o.bF.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}constructor(t,a){this.featureName=o.d5.name,this.setDefaultRoyaltyInfo=(0,n.f)(async t=>{let a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),o=await this.metadata._parseAndUploadMetadata(e);if((0,r.h)("setContractURI",this.contractWrapper)){let t=new s.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[o])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}),this.setTokenRoyaltyInfo=(0,n.f)(async(t,a)=>{let e=o.bF.parse(a);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}),this.contractWrapper=t,this.metadata=a}}class m{async getBatchesToReveal(){let t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];let a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map(t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")})),n=e.slice(0,e.length-1),o=await Promise.all(Array.from([0,...n]).map(t=>this.getNftMetadata(t.toString()))),s=await this.isLegacyContract(),l=(await Promise.all(Array.from([...e]).map(t=>s?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t])))).map(t=>i.hexDataLength(t)>0?s?t:c.$.decode(["bytes","bytes32"],t)[0]:t);return o.map((t,a)=>({batchId:p.O$.from(a),batchUri:t.uri,placeholderMetadata:t})).filter((t,a)=>i.hexDataLength(l[a])>0)}async hashDelayRevealPassword(t,a){let e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return l.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,f.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){}return!1}async getLegacyEncryptedData(t){let a=(await e.e(5834).then(e.t.bind(e,5834,19))).default,r=new d.CH(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}constructor(t,a,e,r){this.createDelayedRevealBatch=(0,n.f)(async(t,a,e,r)=>{let o;if(!e)throw Error("Password is required");let s=await this.storage.uploadBatch([u.C.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),i=(0,f.g)(s),p=await this.nextTokenIdToMintFn(),d=await this.storage.uploadBatch(a.map(t=>u.C.parse(t)),{onProgress:null==r?void 0:r.onProgress,rewriteFileNames:{fileStartNumber:p.toNumber()}}),y=(0,f.g)(d),g=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(g,e),m=await this.contractWrapper.read("encryptDecrypt",[h.Y0(y),w]);if(await this.isLegacyContract())o=m;else{let t=await this.contractWrapper.getChainID(),a=l.keccak256(["bytes","bytes","uint256"],[h.Y0(y),w,t]);o=c.$.encode(["bytes","bytes32"],[m,a])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[d.length,i.endsWith("/")?i:"".concat(i,"/"),o],parse:t=>{let a=this.contractWrapper.parseLogs("TokensLazyMinted",null==t?void 0:t.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let a=e;a.lte(r);a=a.add(1))n.push({id:a,receipt:t});return n}})}),this.reveal=(0,n.f)(async(t,a)=>{if(!a)throw Error("Password is required");let e=await this.hashDelayRevealPassword(t,a);try{let a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw Error("invalid password")}catch(t){throw Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}),this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}}async function I(t,a,e,r,n){let s={},i=r||o.aV,c=(await (0,g.n)(t.getProvider(),a,i)).mul(e);return c.gt(0)&&(i===o.aV?s={value:c}:i!==o.aV&&n&&await (0,y.a)(t,i,c,e,0)),s}class W{async get(){return this.contractWrapper.read("owner",[])}constructor(t){this.featureName=o.d6.name,this.set=(0,n.f)(async t=>{let a=await (0,o.aL)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})}),this.contractWrapper=t}}}}]);