"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[68079],{11454:function(e,t,r){r.d(t,{E:function(){return l},R:function(){return s},S:function(){return o},a:function(){return u}});var a=r(61501),i=r(30248),n=r(89586);let s=i.z.union([i.z.date().transform(e=>a.O$.from(Math.floor(e.getTime()/1e3))),i.z.number().transform(e=>a.O$.from(e))]),o=s.default(new Date(0)),l=s.default(new Date(Date.now()+31536e7));function u(e,t){if(!e)throw new n.x(t);return e}},13957:function(e,t,r){r.d(t,{C:function(){return l}});var a=r(45094),i=r(89586),n=r(13545),s=r(21325),o=r(12158);class l{async getAll(){(0,a.Z)(this.roles.length,"this contract has no support for roles");let e={},t=Object.entries(this.roles);return(await Promise.all(t.map(e=>{let[,t]=e;return this.get(t)}))).forEach((r,a)=>e[t[a][1]]=r),e}async get(e){(0,a.Z)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));let t=this.contractWrapper;if((0,n.h)("getRoleMemberCount",t)&&(0,n.h)("getRoleMember",t)){let r=(0,i.H)(e),a=(await t.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map(e=>t.read("getRoleMember",[r,e])))}throw Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}async verify(e,t){await Promise.all(e.map(async e=>{let[r,a]=await Promise.all([this.get(e),(0,i.aL)(t)]);if(!r.map(e=>e.toLowerCase()).includes(a.toLowerCase()))throw new i.o(a,e)}))}async getRevokeRoleFunctionName(e){let[t,r]=await Promise.all([(0,i.aL)(e),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===t.toLowerCase()?"renounceRole":"revokeRole"}constructor(e,t){this.featureName=i.d4.name,this.setAll=(0,s.f)(async(e,t)=>{let r=t||await this.contractWrapper.getSignerAddress(),n=new o.C(this.contractWrapper),l=Object.keys(e);(0,a.Z)(l.length,"you must provide at least one role to set"),(0,a.Z)(l.every(e=>this.roles.includes(e)),"this contract does not support the given role");let u=await this.getAll(),f=[],c=l.sort(e=>"admin"===e?1:-1);for(let t=0;t<c.length;t++){var h,p;let a=c[t],[s,o]=await Promise.all([Promise.all((null===(h=e[a])||void 0===h?void 0:h.map(e=>(0,i.aL)(e)))||[]),Promise.all((null===(p=u[a])||void 0===p?void 0:p.map(e=>(0,i.aL)(e)))||[])]),l=s.filter(e=>!o.includes(e)),m=o.filter(e=>!s.includes(e));if(m.length>1){let e=m.indexOf(r);e>-1&&(m.splice(e,1),m.push(r))}l.length&&l.forEach(e=>{f.push(n.encode("grantRole",[(0,i.H)(a),e]))}),m.length&&(await Promise.all(m.map(e=>this.getRevokeRoleFunctionName(e)))).forEach((e,t)=>f.push(n.encode(e,[(0,i.H)(a),m[t]])))}return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[f]})}),this.grant=(0,s.f)(async(e,t)=>{(0,a.Z)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));let r=await (0,i.aL)(t);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,i.H)(e),r]})}),this.revoke=(0,s.f)(async(e,t)=>{(0,a.Z)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));let r=await (0,i.aL)(t),n=await this.getRevokeRoleFunctionName(r);return s.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:n,args:[(0,i.H)(e),r]})}),this.contractWrapper=e,this.roles=t}}},15418:function(e,t,r){r.d(t,{B:function(){return l},C:function(){return u},N:function(){return f},a:function(){return c},s:function(){return h}});var a=r(89586),i=r(30248),n=r(12158);let s=i.z.object({}).catchall(i.z.union([a.cx,i.z.unknown()])),o=i.z.union([i.z.array(i.z.array(s)).transform(e=>e.flat()),i.z.array(s),s]).optional().nullable(),l=i.z.object({name:i.z.union([i.z.string(),i.z.number()]).optional().nullable(),description:i.z.string().nullable().optional().nullable(),image:a.cy.nullable().optional(),animation_url:a.cy.optional().nullable()}),u=l.extend({external_url:a.cy.nullable().optional(),background_color:a.cz.optional().nullable(),properties:o,attributes:o}).catchall(i.z.union([a.cx,i.z.unknown()])),f=i.z.union([u,i.z.string()]),c=u.extend({id:i.z.string(),uri:i.z.string(),image:i.z.string().nullable().optional(),external_url:i.z.string().nullable().optional(),animation_url:i.z.string().nullable().optional()});async function h(e,t,i,s){if((0,n.i)(i))s.value=t;else{let n=(await Promise.resolve().then(r.t.bind(r,54497,19))).default,o=e.getSigner(),l=e.getProvider(),u=new a.cs(o||l,i,n,e.options,e.storage),f=await e.getSignerAddress(),c=e.address;return(await u.read("allowance",[f,c])).lt(t)&&await u.sendTransaction("approve",[c,t]),s}}},23198:function(e,t,r){let a;r.d(t,{A:function(){return j},B:function(){return en},C:function(){return ea},D:function(){return E},E:function(){return q},F:function(){return U},H:function(){return Q},I:function(){return z},J:function(){return N},K:function(){return er},L:function(){return ei},M:function(){return em},S:function(){return es},a:function(){return W},f:function(){return F},n:function(){return eo},r:function(){return ef},s:function(){return ec},t:function(){return eh},u:function(){return ep},v:function(){return ed},w:function(){return ey},x:function(){return eg},y:function(){return et},z:function(){return D}});var i,n,s=r(99790),o=r(73877),l=r(57289),u=r(83531),f=r(69774),c=r(61501),h=r(46347),p=r(60105),m=r(89586),d=r(12158),y=r(78680),g=r(23663),b=r(48160),w=r.n(b),v=r(74520);class x{print(){x.print(this)}bufferIndexOf(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return r?this.binarySearch(e,t,g.Buffer.compare):this.linearSearch(e,t,(e,t)=>e.equals(t))}static binarySearch(e,t,r){let a=0,i=e.length-1;for(;a<=i;){let n=Math.floor((a+i)/2),s=r(e[n],t);if(0===s){for(let a=n-1;a>=0;a--)if(0!==r(e[a],t))return a+1;return 0}s<0?a=n+1:i=n-1}return -1}binarySearch(e,t,r){return x.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let a=0;a<e.length;a++)if(r(e[a],t))return a;return -1}linearSearch(e,t,r){return x.linearSearch(e,t,r)}static bufferify(e){if(!g.Buffer.isBuffer(e)){if("object"==typeof e&&e.words)return g.Buffer.from(e.toString(T),"hex");if(x.isHexString(e))return g.Buffer.from(e.replace(/^0x/,""),"hex");if("string"==typeof e)return g.Buffer.from(e);if("bigint"==typeof e)return g.Buffer.from(e.toString(16),"hex");else if(e instanceof Uint8Array)return g.Buffer.from(e.buffer);else if("number"==typeof e){let t=e.toString();return t.length%2&&(t="0".concat(t)),g.Buffer.from(t,"hex")}else if(ArrayBuffer.isView(e))return g.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return x.bigNumberify(e)}static bigNumberify(e){if("bigint"==typeof e)return e;if("string"==typeof e)return e.startsWith("0x")&&x.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(g.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){let t=Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join("");return BigInt("0x".concat(t))}(e);if("number"==typeof e)return BigInt(e);throw Error("cannot bigNumberify")}static isHexString(e){return"string"==typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return x.bufferToHex(e,t)}static bufferToHex(e){let t=!(arguments.length>1)||void 0===arguments[1]||arguments[1];return"".concat(t?"0x":"").concat((e||g.Buffer.alloc(0)).toString("hex"))}bufferify(e){return x.bufferify(e)}bufferifyFn(e){return t=>{var r;let a=e(t);if(g.Buffer.isBuffer(a))return a;if(this.isHexString(a))return g.Buffer.from(a.replace("0x",""),"hex");if("string"==typeof a)return g.Buffer.from(a);if("bigint"==typeof a)return g.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(a))return g.Buffer.from(a.buffer,a.byteOffset,a.byteLength);let i=(r=e(function(e){let t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex"))),Array.from(new Uint8Array(r)).map(e=>e.toString(16).padStart(2,"0")).join(""));return g.Buffer.from(i,"hex")}}isHexString(e){return x.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map((e,r)=>[e,t[r]])}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var S=x;function T(e){let t=e.words,r=new ArrayBuffer(4*t.length),a=new Uint8Array(r);for(let e=0;e<t.length;e++)a[4*e]=t[e]>>24&255,a[4*e+1]=t[e]>>16&255,a[4*e+2]=t[e]>>8&255,a[4*e+3]=255&t[e];return r}class P extends S{getOptions(){var e,t;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:null!==(t=null===(e=this.fillDefaultHash)||void 0===e?void 0:e.toString())&&void 0!==t?t:null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(g.Buffer.compare)),this.fillDefaultHash)for(let e=this.leaves.length;e<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));e++)this.leaves.push(this.bufferify(this.fillDefaultHash(e,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){let t=this.layers.length;this.layers.push([]);let r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=r){this.layers[t].push(...e.slice(r));break}if(a+1===e.length&&e.length%2==1){let r=e[e.length-1],i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([w()(r),w()(r)])),i=w()(this.hashFn(i)),this.layers[t].push(i);continue}if(this.duplicateOdd);else{this.layers[t].push(e[a]);continue}}let i=e[a],n=a+1===e.length?i:e[a+1],s=null;s=this.isBitcoinTree?[w()(i),w()(n)]:[i,n],this.sortPairs&&s.sort(g.Buffer.compare);let o=this.hashFn(this.concatenator(s));this.isBitcoinTree&&(o=w()(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(g.Buffer.compare))),this.leaves.filter(t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?g.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);let t=this.getLeaves();for(let r=0;r<t.length;r++)if(t[r].equals(e))return r;return -1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map(e=>this.bufferToHex(e))}static marshalLeaves(e){return JSON.stringify(e.map(e=>P.bufferToHex(e)),null,2)}static unmarshalLeaves(e){let t=null;if("string"==typeof e)t=JSON.parse(e);else if(e instanceof Object)t=e;else throw Error("Expected type of string or object");if(!t)return[];if(!Array.isArray(t))throw Error("Expected JSON string to be array");return t.map(P.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce((e,t)=>(Array.isArray(t)?e.push(t.map(e=>this.bufferToHex(e))):e.push(t),e),[])}getLayersFlat(){let e=this.layers.reduce((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e),[]);return e.unshift(g.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map(e=>this.bufferToHex(e))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?g.Buffer.from([]):this.layers[this.layers.length-1][0]||g.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if(void 0===e)throw Error("leaf is required");e=this.bufferify(e);let r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===g.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let e=0;e<this.layers.length;e++){let a=this.layers[e],i=t%2,n=i?t-1:this.isBitcoinTree&&t===a.length-1&&e<this.layers.length-1?t:t+1;n<a.length&&r.push({position:i?"left":"right",data:a[n]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map(e=>this.bufferToHex(e.data))}getProofs(){let e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,a){let i=t%2;if(-1===e){i||a.push([...r].reverse());return}if(t>=this.layers[e].length)return;let n=this.layers[e],s=i?t-1:t+1,o=!1;s<n.length&&(o=!0,r.push({position:i?"left":"right",data:n[s]})),this.getProofsDFS(e-1,2*t,r,a),this.getProofsDFS(e-1,2*t+1,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map(e=>this.bufferToHex(e.data))}getPositionalHexProof(e,t){return this.getProof(e,t).map(e=>["left"===e.position?0:1,this.bufferToHex(e.data)])}getProofIndices(e,t){let r=2**t,a=new Set;for(let t of e){let e=r+t;for(;e>1;)a.add(1^e),e=e/2|0}let i=e.map(e=>r+e),n=Array.from(a).sort((e,t)=>e-t).reverse();a=i.concat(n);let s=new Set,o=[];for(let e of a)if(!s.has(e))for(o.push(e);e>1&&(s.add(e),s.has(1^e));)e=e/2|0;return o.filter(t=>!e.includes(t-r))}getProofIndicesForUnevenTree(e,t){let r=Math.ceil(Math.log2(t)),a=[];for(let e=0;e<r;e++)t%2!=0&&a.push({index:e,leavesCount:t}),t=Math.ceil(t/2);let i=[],n=e;for(let e=0;e<r;e++){let t=n.map(e=>e%2==0?e+1:e-1).filter(e=>!n.includes(e)),r=a.find(t=>{let{index:r}=t;return r===e});r&&n.includes(r.leavesCount-1)&&(t=t.slice(0,-1)),i.push(t),n=[...new Set(n.map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))]}return i}getMultiProof(e,t){if(this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat()),this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(g.Buffer.compare));let r=e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1);if(!r.every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let a=[],i=[],n=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];for(let e=0;e<r.length;e++){let s=r[e],o=this.getPairNode(t,s);a.push(t[s]),o&&i.push(o),n.push(s/2|0)}r=n.filter((e,t,r)=>r.indexOf(e)===t),n=[]}return i.filter(e=>!a.includes(e))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map(t=>e[t])}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],a=t;for(let t of e){let e=[];for(let r of a){if(r%2==0){let i=r+1;if(!a.includes(i)&&t[i]){e.push(t[i]);continue}}let i=r-1;if(!a.includes(i)&&t[i]){e.push(t[i]);continue}}r=r.concat(e);let i=new Set;for(let e of a){if(e%2==0){i.add(e/2);continue}if(e%2==0){i.add((e+1)/2);continue}i.add((e-1)/2)}a=Array.from(i)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map(e=>this.bufferToHex(e))}getProofFlags(e,t){let r;if(!Array.isArray(e)||e.length<=0)throw Error("Invalid Inputs!");if(!(r=e.every(Number.isInteger)?[...e].sort((e,t)=>e===t?0:e>t?1:-1):e.map(e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves)).sort((e,t)=>e===t?0:e>t?1:-1)).every(e=>-1!==e))throw Error("Element does not exist in Merkle tree");let a=t.map(e=>this.bufferify(e)),i=[],n=[];for(let e=0;e<this.layers.length;e++){let t=this.layers[e];r=r.reduce((e,r)=>{if(!i.includes(t[r])){let e=this.getPairNode(t,r),s=a.includes(t[r])||a.includes(e);e&&n.push(!s),i.push(t[r]),i.push(e)}return e.push(r/2|0),e},[])}return n}verify(e,t,r){let a=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let t=0;t<e.length;t++){let r=e[t],i=null,n=null;if("string"==typeof r)i=this.bufferify(r),n=!0;else if(Array.isArray(r))n=0===r[0],i=this.bufferify(r[1]);else if(g.Buffer.isBuffer(r))i=r,n=!0;else if(r instanceof Object)i=this.bufferify(r.data),n="left"===r.position;else throw Error("Expected node to be of type string or object");let s=[];this.isBitcoinTree?(s.push(w()(a)),s[n?"unshift":"push"](w()(i)),a=this.hashFn(this.concatenator(s)),a=w()(this.hashFn(a))):(this.sortPairs?-1===g.Buffer.compare(a,i)?s.push(a,i):s.push(i,a):(s.push(a),s[n?"unshift":"push"](i)),a=this.hashFn(this.concatenator(s)))}return 0===g.Buffer.compare(a,r)}verifyMultiProof(e,t,r,a,i){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,a,i);let n=Math.ceil(Math.log2(a));e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));let s={};for(let[e,a]of this.zip(t,r))s[2**n+e]=a;for(let[e,r]of this.zip(this.getProofIndices(t,n),i))s[e]=r;let o=Object.keys(s).map(e=>Number(e)).sort((e,t)=>e-t);o=o.slice(0,o.length-1);let l=0;for(;l<o.length;){let e=o[l];if(e>=2&&({}).hasOwnProperty.call(s,1^e)){let t=[s[e-e%2],s[e-e%2+1]];this.sortPairs&&(t=t.sort(g.Buffer.compare));let r=t[1]?this.hashFn(this.concatenator(t)):t[0];s[e/2|0]=r,o.push(e/2|0)}l+=1}return!t.length||({}).hasOwnProperty.call(s,1)&&s[1].equals(e)}verifyMultiProofWithFlags(e,t,r,a){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);let i=t.length,n=a.length,s=[],o=0,l=0,u=0;for(let e=0;e<n;e++){let n=[a[e]?o<i?t[o++]:s[l++]:r[u++],o<i?t[o++]:s[l++]].sort(g.Buffer.compare);s[e]=this.hashFn(this.concatenator(n))}return 0===g.Buffer.compare(s[n-1],e)}verifyMultiProofForUnevenTree(e,t,r,a,i){e=this.bufferify(e),r=r.map(e=>this.bufferify(e)),i=i.map(e=>this.bufferify(e));let n=this.calculateRootForUnevenTree(t,r,a,i);return e.equals(n)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){let e=this.getLayers().map(e=>e.map(e=>this.bufferToHex(e,!1))),t=[];for(let r=0;r<e.length;r++){let a=[];for(let i=0;i<e[r].length;i++){let n={[e[r][i]]:null};if(t.length){n[e[r][i]]={};let a=t.shift(),s=Object.keys(a)[0];if(n[e[r][i]][s]=a[s],t.length){let a=t.shift(),s=Object.keys(a)[0];n[e[r][i]][s]=a[s]}}a.push(n)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){let r=t%2==0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){let e=this.getLayersAsObject();return(0,v.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){let t=(null==e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,a){let i=this.zip(e,t).sort((e,t)=>{let[r]=e,[a]=t;return r-a}),n=i.map(e=>{let[t]=e;return t}),s=this.getProofIndicesForUnevenTree(n,r),o=0,l=[];for(let e=0;e<s.length;e++){let t=s[e],r=o;o+=t.length,l[e]=this.zip(t,a.slice(r,o))}let u=[i];for(let e=0;e<l.length;e++){let t=l[e].concat(u[e]).sort((e,t)=>{let[r]=e,[a]=t;return r-a}).map(e=>{let[,t]=e;return t}),r=u[e].map(e=>{let[t]=e;return t}),a=[...new Set(r.map(e=>e%2==0?e/2:e%2==0?(e+1)/2:(e-1)/2))],i=[];for(let e=0;e<a.length;e++){let r=a[e],n=t[2*e],s=t[2*e+1],o=s?this.hashFn(this.concatenator([n,s])):n;i.push([r,o])}u.push(i)}return u[u.length-1][0][1]}constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),this.duplicateOdd=!1,this.concatenator=g.Buffer.concat,this.hashLeaves=!1,this.isBitcoinTree=!1,this.leaves=[],this.layers=[],this.sortLeaves=!1,this.sortPairs=!1,this.sort=!1,this.fillDefaultHash=null,this.complete=!1,r.complete){if(r.isBitcoinTree)throw Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash){if("function"==typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else if(g.Buffer.isBuffer(r.fillDefaultHash)||"string"==typeof r.fillDefaultHash)this.fillDefaultHash=(e,t)=>r.fillDefaultHash;else throw Error('method "fillDefaultHash" must be a function, Buffer, or string')}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}}var k=r(11454),C=r(30248),B=r(15418),A={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let O=new Uint8Array(16),L=[];for(let e=0;e<256;++e)L.push((e+256).toString(16).slice(1));var R=function(e,t,r){if(A.randomUUID&&!t&&!e)return A.randomUUID();let i=(e=e||{}).random||(e.rng||function(){if(!a&&!(a="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)))throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return a(O)})();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=i[e];return t}return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[e[t+0]]+L[e[t+1]]+L[e[t+2]]+L[e[t+3]]+"-"+L[e[t+4]]+L[e[t+5]]+"-"+L[e[t+6]]+L[e[t+7]]+"-"+L[e[t+8]]+L[e[t+9]]+"-"+L[e[t+10]]+L[e[t+11]]+L[e[t+12]]+L[e[t+13]]+L[e[t+14]]+L[e[t+15]]}(i)},H=r(23663).Buffer;function z(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function N(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function E(e,t){return"unlimited"===e?s.Bz:o.parseUnits(e,t)}async function I(e){let t=Array.from({length:Math.ceil(e.length/25e3)},(t,r)=>e.slice(25e3*r,25e3*r+25e3)),r=[];for(let e of(await Promise.all(t.map(e=>m.bM.parseAsync(e)))))r.push(...e);return r}let U=((i={})[i.V1=1]="V1",i[i.V2=2]="V2",i);class M{static async fromUri(e,t){try{let r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return M.fromShardedMerkleTreeInfo(r,t)}catch(e){return}}static async fromShardedMerkleTreeInfo(e,t){return new M(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,a){switch(a){case U.V1:return l.keccak256(["address","uint256"],[e.address,E(e.maxClaimable,t)]);case U.V2:return l.keccak256(["address","uint256","uint256","address"],[e.address,E(e.maxClaimable,t),E(e.price||"unlimited",r),e.currencyAddress||u.d])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let a=e[r];return void 0===a&&(a=(await (0,d.f)(t,r)).decimals,e[r]=a),a}static async buildAndUpload(e,t,r,a,i){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2,s=await I(e),o={};for(let e of s){let t=e.address.slice(2,2+n).toLowerCase();void 0===o[t]&&(o[t]=[]),o[t].push(e)}let l={},u=Object.fromEntries(await Promise.all(Object.entries(o).map(async e=>{let[a,n]=e;return[a,new P(await Promise.all(n.map(async e=>{let a=await M.fetchAndCacheDecimals(l,r,e.currencyAddress);return M.hashEntry(e,t,a,i)})),f.keccak256,{sort:!0}).getHexRoot()]}))),c=new P(Object.values(u),f.keccak256,{sort:!0}),h=[];for(let[e,t]of Object.entries(o)){let r={proofs:c.getProof(u[e]).map(e=>"0x"+e.data.toString("hex")),entries:t};h.push({data:JSON.stringify(r),name:"".concat(e,".json")})}let p=await a.uploadBatch(h),m=p[0].slice(0,p[0].lastIndexOf("/")),d=await a.upload(s),y={merkleRoot:c.getHexRoot(),baseUri:m,originalEntriesUri:d,shardNybbles:n,tokenDecimals:t,isShardedMerkleTree:!0},g=await a.upload(y);return{shardedMerkleInfo:y,uri:g}}async getProof(e,t,r){let a=e.slice(2,2+this.shardNybbles).toLowerCase(),i=this.shards[a],n={};if(void 0===i)try{let e=this.baseUri.endsWith("/")?this.baseUri:"".concat(this.baseUri,"/");i=this.shards[a]=await this.storage.downloadJSON("".concat(e).concat(a,".json"));let s=await Promise.all(i.entries.map(async e=>{let a=await M.fetchAndCacheDecimals(n,t,e.currencyAddress);return M.hashEntry(e,this.tokenDecimals,a,r)}));this.trees[a]=new P(s,f.keccak256,{sort:!0})}catch(e){return null}let s=i.entries.find(t=>t.address.toLowerCase()===e.toLowerCase());if(!s)return null;let o=await M.fetchAndCacheDecimals(n,t,s.currencyAddress),l=M.hashEntry(s,this.tokenDecimals,o,r),u=this.trees[a].getProof(l).map(e=>"0x"+e.data.toString("hex"));return m.bN.parseAsync({...s,proof:u.concat(i.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}constructor(e,t,r,a,i){this.storage=e,this.shardNybbles=a,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=i,this.shards={},this.trees={}}}async function F(e,t,r,a,i,n){if(!r)return null;let s=r[t];if(s){let r=await i.downloadJSON(s);if(r.isShardedMerkleTree&&r.merkleRoot===t){let t=await M.fromShardedMerkleTreeInfo(r,i);return await t.getProof(e,a,n)}let o=await m.bO.parseAsync(r);if(t===o.merkleRoot)return o.claims.find(t=>t.address.toLowerCase()===e.toLowerCase())||null}return null}function D(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function j(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function W(e,t,a,i,n){let s=e.getSigner(),l=e.getProvider(),u=(await Promise.resolve().then(r.t.bind(r,54497,19))).default,f=new m.cs(s||l,t,u,e.options,e.storage),h=await e.getSignerAddress(),p=e.address,d=await f.read("allowance",[h,p]),y=c.O$.from(a).mul(c.O$.from(i)).div(o.parseUnits("1",n));d.lt(y)&&await f.sendTransaction("approve",[p,d.add(y)])}async function q(e,t,r,a,i,n,l,f,p){let m=E(r.maxClaimablePerWallet,i),g=[h.hexZeroPad([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(u.d)){let t=await F(e,r.merkleRootHash.toString(),await a(),n.getProvider(),l,p);if(t)g=t.proof,m="unlimited"===t.maxClaimable?s.Bz:o.parseUnits(t.maxClaimable,i),b=void 0===t.price||"unlimited"===t.price?s.Bz:await (0,y.n)(n.getProvider(),t.price,t.currencyAddress||u.d),w=t.currencyAddress||u.d;else if(p===U.V1)throw Error("No claim found for this address")}}catch(e){if((null==e?void 0:e.message)==="No claim found for this address")throw e;console.warn("failed to check claim condition merkle root hash, continuing anyways",e)}let v=await n.getCallOverrides()||{},x=b.toString()!==s.Bz.toString()?b:r.price,S=w!==u.d?w:r.currencyAddress;return x.gt(0)&&((0,d.i)(S)?v.value=c.O$.from(x).mul(t).div(o.parseUnits("1",i)):f&&await W(n,S,x,t,i)),{overrides:v,proofs:g,maxClaimable:m,price:x,currencyAddress:S,priceInProof:b,currencyAddressInProof:w}}let V=C.z.object({name:C.z.string(),symbol:C.z.string(),decimals:C.z.number()}).extend({value:m.b5,displayValue:C.z.string()}),J=C.z.object({name:C.z.string().optional()}).catchall(C.z.unknown()),$=C.z.object({startTime:k.S,currencyAddress:C.z.string().default(m.aV),price:m.cw.default(0),maxClaimableSupply:m.cA,maxClaimablePerWallet:m.cA,waitInSeconds:m.b6.default(0),merkleRootHash:m.cB.default(h.hexZeroPad([0],32)),snapshot:C.z.optional(m.bM).nullable(),metadata:J.optional()}),Z=C.z.array($),_=$.extend({availableSupply:m.cA,currentMintSupply:m.cA,currencyMetadata:V.default({value:c.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:m.b5,waitInSeconds:m.b5,startTime:m.b5.transform(e=>new Date(1e3*e.toNumber())),snapshot:m.bM.optional().nullable()});async function Y(e,t,r,a,i){let n=await I(e),s=n.map(e=>e.address);if(new Set(s).size<s.length)throw new m.s;let o=await M.buildAndUpload(n,t,r,a,i);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}async function K(e,t,r,a,i){let n=[];return{inputsWithSnapshots:await Promise.all(e.map(async e=>{if(e.snapshot&&e.snapshot.length>0){let s=await Y(e.snapshot,t,r,a,i);n.push(s),e.merkleRootHash=s.merkleRoot}else e.merkleRootHash=h.hexZeroPad([0],32);return e})),snapshotInfos:n}}async function G(e,t,r,a){let i;let n=e.currencyAddress===u.d?m.aV:e.currencyAddress,s=E(e.maxClaimableSupply,t),o=E(e.maxClaimablePerWallet,t);return e.metadata&&(i="string"==typeof e.metadata?e.metadata:await a.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await (0,y.n)(r,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:i}}async function Q(e,t,r,a,i){let{inputsWithSnapshots:n,snapshotInfos:s}=await K(e,t,r,a,i),o=await Z.parseAsync(n);return{snapshotInfos:s,sortedConditions:(await Promise.all(o.map(e=>G(e,t,r,a)))).sort((e,t)=>(function(e,t){let r=c.O$.from(e),a=c.O$.from(t);return r.eq(a)?0:r.gt(a)?1:-1})(e.startTimestamp,t.startTimestamp))}}async function X(e,t,r){if(!t)return null;let a=t[e];if(a){let t=await r.downloadJSON(a);if(t.isShardedMerkleTree&&t.merkleRoot===e){let e=await M.fromUri(a,r);return(null==e?void 0:e.getAllEntries())||null}{let r=await m.bO.parseAsync(t);if(e===r.merkleRoot)return r.claims.map(e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress}))}}return null}function ee(e,t){return e.toString()===s.Bz.toString()?"unlimited":o.formatUnits(e,t)}async function et(e,t,r,a,i,n){var s;let o;let l=await (0,d.a)(r,e.currency,e.pricePerToken),u=ee(e.maxClaimableSupply,t),f=ee(e.maxClaimablePerWallet,t),h=ee(c.O$.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),p=ee(e.supplyClaimed,t);return e.metadata&&(o=await i.downloadJSON(e.metadata)),_.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:u,maxClaimablePerWallet:f,currentMintSupply:p,availableSupply:h,waitInSeconds:null===(s=e.waitTimeInSecondsBetweenClaims)||void 0===s?void 0:s.toString(),price:c.O$.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:l,merkleRootHash:e.merkleRoot,snapshot:n?await X(e.merkleRoot,a,i):void 0,metadata:o})}async function er(e,t,r){if(e>=r.length)throw Error("Index out of bounds - got index: ".concat(e," with ").concat(r.length," conditions"));let a=r[e].currencyMetadata.decimals,i=r[e].price,n=o.formatUnits(i,a),s=await $.parseAsync({...r[e],price:n,...t}),l=await _.parseAsync({...s,price:i});return r.map((t,r)=>{let i;i=r===e?l:t;let n=o.formatUnits(i.price,a);return{...i,price:n}})}let ea=((n={}).NotEnoughSupply="There is not enough supply to claim.",n.AddressNotAllowed="This address is not on the allowlist.",n.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",n.ClaimPhaseNotStarted="Claim phase has not started yet.",n.AlreadyClaimed="You have already claimed the token.",n.WrongPriceOrCurrency="Incorrect price or currency.",n.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",n.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",n.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",n.NoClaimConditionSet="There is no claim condition set.",n.NoWallet="No wallet connected.",n.Unknown="No claim conditions found.",n);function ei(e){if(void 0!==e)return h.hexlify(e);{let e=H.alloc(16);return R({},e),h.hexlify(p.Y0(e.toString("hex")))}}let en=C.z.object({to:m.b9.refine(e=>e.toLowerCase()!==u.d,{message:"Cannot create payload to mint to zero address"}),price:m.cw.default(0),currencyAddress:m.b8.default(m.aV),mintStartTime:k.S,mintEndTime:k.E,uid:C.z.string().optional().transform(e=>ei(e)),primarySaleRecipient:m.b9.default(u.d)}),es=en.extend({quantity:m.cw}),eo=es.extend({mintStartTime:m.b5,mintEndTime:m.b5}),el=en.extend({metadata:B.N,royaltyRecipient:C.z.string().default(u.d),royaltyBps:m.cC.default(0)}),eu=el.extend({metadata:B.N.default(""),uri:C.z.string(),royaltyBps:m.b5,mintStartTime:m.b5,mintEndTime:m.b5}),ef=el.extend({metadata:B.N.default(""),quantity:m.b6}).extend({tokenId:m.b6}),ec=eu.extend({tokenId:m.b5,quantity:m.b5}),eh=el.extend({metadata:B.N.default(""),quantity:m.b5.default(1)}),ep=eu.extend({quantity:m.b5.default(1)}),em=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ed=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ey=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],eg=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},48160:function(e,t,r){var a=r(23663).Buffer;e.exports=function(e){for(var t=new a(e.length),r=0,i=e.length-1;r<=i;++r,--i)t[r]=e[i],t[i]=e[r];return t}},50144:function(e){e.exports=function e(t,r){if(t===r)return!0;if(t&&r&&"object"==typeof t&&"object"==typeof r){if(t.constructor!==r.constructor)return!1;if(Array.isArray(t)){if((a=t.length)!=r.length)return!1;for(i=a;0!=i--;)if(!e(t[i],r[i]))return!1;return!0}if(t.constructor===RegExp)return t.source===r.source&&t.flags===r.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===r.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===r.toString();if((a=(n=Object.keys(t)).length)!==Object.keys(r).length)return!1;for(i=a;0!=i--;)if(!Object.prototype.hasOwnProperty.call(r,n[i]))return!1;for(i=a;0!=i--;){var a,i,n,s=n[i];if(!e(t[s],r[s]))return!1}return!0}return t!=t&&r!=r}},74520:function(e){e.exports=function(){function e(t,r,a,i,n,s,o){var l,u,f,c="",h=0,p=i.slice(0);if(p.push([r,a])&&i.length>0&&(i.forEach(function(e,t){t>0&&(c+=(e[1]?" ":"│")+"  "),f||e[0]!==r||(f=!0)}),c+=(l=a?"└":"├",t?l+="─ ":l+="──┐",l+t),n&&("object"!=typeof r||r instanceof Date)&&(c+=": "+r),f&&(c+=" (circular ref.)"),o(c)),!f&&"object"==typeof r){var m=function(e,t){var r=[];for(var a in e)e.hasOwnProperty(a)&&(!t||"function"!=typeof e[a])&&r.push(a);return r}(r,s);m.forEach(function(t){u=++h===m.length,e(t,r[t],u,p,n,s,o)})}}var t={};return t.asLines=function(t,r,a,i){e(".",t,!1,[],r,"function"!=typeof a&&a,i||a)},t.asTree=function(t,r,a){var i="";return e(".",t,!1,[],r,a,function(e){i+=e+"\n"}),i},t}()}}]);